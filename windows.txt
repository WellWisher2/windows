1) Sort a given set of n integer elements using Selection Sort method and compute its time
complexity. Run the program for varied values of n&gt;5000 and record the time taken to sort.
Plot a graph of the time taken versus n. The elements can be read from a file or can be
generated using the random number generator. Demonstrate using C++/Java how the brute
force method works along with its time complexity analysis: worst case, average case and
best case.
-----------------------------------------------------------------------------------------------------
Program:-

import java.util.Scanner;
import java.util.Random;
import java.io.*;
public class SelectionSort {
/**
* @param args the command line arguments
*/
static int size; 
public static void main(String[] args) throws IOException
{
Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the number of elements to sorted: ( &gt;5000):&quot;);
size = in.nextInt();
int inputArr [] = new int[size];
genRandomNumbers(inputArr);

long startTime = System.nanoTime();
selection(inputArr,size-1);
long estimatedTime = System.nanoTime() - startTime;
PrintWriter outA = new PrintWriter(new File(&quot;ssort.txt&quot;));
for(int i=0;i&lt;inputArr.length;i++)
{
outA.println(inputArr[i]);

}
outA.close();
System.out.println(&quot;The time complexity for best,average and worst case is &quot; +
(estimatedTime/1000000.0)+ &quot; ms&quot;);
}

public static void genRandomNumbers(int inputArr[]) throws IOException
{
int number, count=0;
Random rand = new Random();
PrintWriter out = new PrintWriter(new File(&quot;Mrandom.txt&quot;));
while(count&lt;size)
{

number=rand.nextInt(size)+1;
out.println(number);
out.print(&quot; &quot;);
inputArr[count]=number;

count++;
}
out.close();
System.out.println(&quot;The total numbers generated: &quot; + count );
}

public static void selection(int a[],int n)
{

for(int i=0; i&lt;=n;i++)
{
int j=i;
for(int k=i+1;k&lt;=n;k++)
{
if(a[k]&lt;a[j])
j=k;
}
int t=a[i];
a[i]= a[j];
a[j]=t;
}
}

}
------------------------------------------------------------------------------------------------------------

2) Sort a given set of n integer elements using Quick Sort method and compute its time
complexity. Run the program for varied values of n&gt;5000 and record the time taken to sort.
Plot a graph of the time taken versus n. The elements can be read from a file or can be
generated using the random number generator. Demonstrate using C++/Java how the
divide-and-conquer method works along with its time complexity analysis: worst case,
average case and best case.

---------------------------------------------------------------------------------------------------------------
Program:-

package quicksort;

import java.util.Scanner;
import java.util.Random;
import java.io.*;
public class QuickSort {
static int size; 
public static void main(String[] args) throws IOException{
Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the number of elements to sorted: ( &gt;5000):&quot;);
size = in.nextInt();

int inputArr [] = new int[size];
genRandomNumbers(inputArr);

long startTime = System.nanoTime();
quickSort(inputArr,0,size-1);
long estimatedTime = System.nanoTime() - startTime;
PrintWriter outA = new PrintWriter(new File(&quot;qsort.txt&quot;));
for(int i=0;i&lt;inputArr.length;i++)
{
outA.println(inputArr[i]);
}
outA.close();
System.out.println(&quot;The time complexity for best case and average case is &quot; +
(estimatedTime/1000000.0)+ &quot; ms&quot;);

startTime = System.nanoTime();
quickSort(inputArr,0,size-1);
estimatedTime = System.nanoTime() - startTime;

System.out.println(&quot;The time complexity for worst case is &quot; +
(estimatedTime/1000000.0)+ &quot; ms&quot;);
}

public static void genRandomNumbers(int inputArr[]) throws IOException
{
int number, count=0;
Random rand = new Random();
PrintWriter out = new PrintWriter(new File(&quot;Random.txt&quot;));
while(count&lt;size)
{
number=rand.nextInt(size)+1;
out.println(number);
inputArr[count]=number;
count++;
}
out.close();
System.out.println(&quot;The total numbers generated: &quot; + count );
}

public static void quickSort(int a[],int low,int high)
{
int j;
if(low&lt;high)
{
j= partition(a,low,high);
quickSort(a,low,j-1);
quickSort(a,j+1,high);
}
}
//Method for Partition
public static int partition(int a[],int low,int high)
{
int i,j,temp,pivot;
pivot = a[low];
i = low + 1;
j = high;
while(true)
{
while(i&lt;high &amp;&amp; a[i]&lt;=pivot)
i++;
while(a[j]&gt;pivot)
j--;
if(i&lt;j)
{
temp = a[i];
a[i] = a[j];

a[j] = temp;
}
else
{
temp = a[low];
a[low] = a[j];
a[j] = temp;
return j;
}
}
} 
}

-------------------------------------------------------------------------------------------------------------------

3) Sort a given set of n integer elements using Merge Sort method and compute its time
complexity. Run the program for varied values of n&gt;5000 and record the time taken to sort.
Plot a graph of the time taken versus n. The elements can be read from a file or can be
generated using the random number generator. Demonstrate using C++/Java how the
divide-and-conquer method works along with its time complexity analysis: worst case,
average case and best case.

----------------------------------------------------------------------------------------------------------------------

Program:-

package mergesort;
import java.util.Scanner;
import java.util.Random;
import java.io.*;
/**
*
* @author Dell
*/
public class MergeSort {
/**
* @param args the command line arguments
*/
static int size; 
public static void main(String[] args) throws IOException {

Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the number of elements to sorted: (&gt;5000):&quot;);
size = in.nextInt();


int inputArr [] = new int[size];
genRandomNumbers(inputArr);

long startTime = System.nanoTime();
mergeSort(inputArr,0,size-1);
long estimatedTime = System.nanoTime() - startTime;
PrintWriter outA = new PrintWriter(new File(&quot;msort.txt&quot;));
for(int i=0;i&lt;inputArr.length;i++)
{
outA.println(inputArr[i]);
}
outA.close();
System.out.println(&quot;The time complexity for best,average and worst case is &quot; +
(estimatedTime/1000000.0)+ &quot; ms&quot;);
}

public static void genRandomNumbers(int inputArr[]) throws IOException
{
int number, count=0;
Random rand = new Random();
PrintWriter out = new PrintWriter(new File(&quot;Mrandom.txt&quot;));
while(count&lt;size)
{
number=rand.nextInt(size)+1;
out.println(number);
out.print(&quot; &quot;);
inputArr[count]=number;
count++;
}
out.close();
System.out.println(&quot;The total numbers generated: &quot; + count );
}
public static void merge(int a[],int low,int mid,int high)
{
int i = low;
int j = mid+1;
int k = low;
int c [] = new int[1000000];
while(i&lt;=mid &amp;&amp; j&lt;=high)
{
if(a[i] &lt; a[j])
{
c[k] = a[i];
i = i+1;
k = k+1;
}

else
{
c[k] = a[j];
j = j+1;
k = k+1;
}
}
while(i&lt;=mid)
{
c[k++] = a[i++];
}
while(j&lt;=high)
{
c[k++] = a[j++];
}
for(i=low;i&lt;=high;i++)
{
a[i] = c[i];
}
}
public static void mergeSort(int a[],int low,int high)
{
int mid;
if(low&lt;high)
{
mid = (low+high)/2;
mergeSort(a,low,mid);
mergeSort(a,mid+1,high);
merge(a,low,mid,high);
}
}
}

-------------------------------------------------------------------------------------------------------------------

4) To solve Knapsack problem using Greedy method

-------------------------------------------------------------------------------------------------------------------


package knapsackgreedy;
import java.util.Scanner;

public class KnapsackGreedy {

public static void main(String[] args) {

int nItems;
Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the number of items: &quot;);
nItems = in.nextInt();
double W; 
double weight[] = new double[nItems]; 
double value[] = new double[nItems]; 
double ratio[] = new double[nItems]; 
System.out.println(&quot;Enter the weights of the item&quot;);
for (int i = 0; i&lt;nItems; i++)
weight[i] = in.nextDouble();
System.out.println(&quot;Enter the values/profits of the item&quot;);
for (int i = 0; i&lt;nItems; i++)
value[i] = in.nextDouble();
for (int i = 0; i&lt;nItems; i++)
ratio[i] = value[i] / weight[i];
System.out.println(&quot;Enter the Capacity of the knapsack: &quot;);
W = in.nextDouble();
System.out.println(&quot;\n The maximum value in a knapsack of capacity &quot; + W+ &quot; is: &quot;+
computeMaxValue(W,weight,value,ratio));
}
public static double computeMaxValue(double W,double weight[],double
value[],double ratio[])
{
double cW = 0; 
double cV = 0; 
System.out.print(&quot;\n Items considered are: &quot;);
while (cW&lt;W)
{
int item = getNextItem(weight,value,ratio);

if (item == -1)
{
//No items left
break;
}

System.out.print((item+1)+&quot; &quot;);
if (cW + weight[item] &lt;= W)
{
cW += weight[item];
cV += value[item];

ratio[item] = 0;
}
else
{
cV += (ratio[item] * (W - cW));

cW += (W - cW);
break; 
}
}
return cV;
}

public static int getNextItem(double weight[],double value[],double ratio[])
{
double highest = 0;
int index = -1;
for (int i = 0; i&lt;value.length; i++)
{
if (ratio[i] &gt;highest)
{
highest = ratio[i];
index = i;
}
}
return index;
}
}



---------------------------------------------------------------------------------------------------------------------

6) To find Minimum Cost Spanning Tree of a given connected undirected graph using Kruskalâ€™s
algorithm. Use Union-Find algorithms in your program.

---------------------------------------------------------------------------------------------------------------------


package kruskals;
import java.util.*;

public class Kruskals {

static int parent[];
static int cost[][];
public static void main(String[] args) {

int i,j,n,min,ne=1;
int u=0,v=0,a=0,b=0,mincost=0;

Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the number of vertices/nodes in the graph&quot;);
n = in.nextInt();
cost = new int[n+1][n+1];
parent= new int[n+1];

System.out.println(&quot;Enter the Cost/Weight matrix&quot;);
for(i=1;i&lt;=n;i++)
{
parent[i]=0;
for(j=1;j&lt;=n;j++)
{
cost[i][j] = in.nextInt();
if(cost[i][j]==0)
cost[i][j]=999;
}
}
System.out.println(&quot;The edges of Minimum spanning tree are:&quot;);
while(ne&lt;n)
{
min = 999;
for(i=1;i&lt;=n;i++)
{
for(j=1;j&lt;=n;j++)
{
if(cost[i][j]&lt;min)
{
min = cost[i][j];
a = u = i;
b = v = j;
}

}
}
u = findParent(u);
v = findParent(v);
if(union(u,v)==1)
{
System.out.println(ne++ + &quot; Edge Selected (&quot; + a +&quot; --- &quot;+ b + &quot;) Cost=&quot; + min);
mincost += min;
}
cost[a][b] = cost[b][a] = 999;
}
System.out.println(&quot;Minimum cost &quot; + mincost);
}

public static int findParent(int i)
{
while(parent[i]!=0)
{
i = parent[i];
}
return i;
}

public static int union(int i,int j)
{
if(i!=j)
{
parent[j]=i;
return 1;
}
return 0;
}
}

--------------------------------------------------------------------------------------------------------------------

7) To find Minimum Cost Spanning Tree of a given connected undirected graph using Primâ€™s
algorithm.

---------------------------------------------------------------------------------------------------------------------

Program:-

package prims;
import java.util.*;


public class Prims {

public static void main(String[] args) {

int i,j,k,n,source;
int w[][] = new int[50][50];
int visited [] = new int[20];
int minWt,totalCost=0,ev=0,sv=0;
Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the no of vertices/nodes in the graph&quot;);
n = in.nextInt();
System.out.println(&quot;Enter the weight/cost matrix&quot;);
for(i=1;i&lt;=n;i++)
{
for(j=1;j&lt;=n;j++)
{
w[i][j] = in.nextInt();
}
}
System.out.println(&quot;Enter the source vertex to start&quot;);
source = in.nextInt();
for(i=1;i&lt;=n;i++)
visited[i] = 0;
visited[source] = 1;
System.out.println(&quot;Minimum Weight/cost edges selected for spanning tree are:&quot;);
for(i=1;i&lt;n;i++)
{
minWt = 999;
for(j=1;j&lt;=n;j++)
{
if(visited[j] == 1)
{
for(k=1;k&lt;=n;k++)
{
if( visited[k]!= 1 &amp;&amp; w[j][k] &lt; minWt)
{
sv = j;

ev = k;
minWt = w[j][k];
}
}
}
}
totalCost += minWt;
visited[ev] = 1;
System.out.println(sv+ &quot; &quot; + &quot;---&gt;&quot; + &quot; &quot;+ ev + &quot; &quot; + &quot;Cost:&quot;+&quot; &quot;+ minWt);
}

System.out.println(&quot;The total cost of minimum spanning tree is &quot;+totalCost);
}
}



----------------------------------------------------------------------------------------------------------------------


10) Solve 0/1 Knapsack problem using Dynamic Programming method

-----------------------------------------------------------------------------------------------------------------------



package knapsackdp;
import java.util.Scanner;
/**
*
* @author Dell
*/
public class KnapSackDP {


public static void main(String[] args) {

int i;
int n; // No of items
int W; // Capacity of the knapSack
int wt[] = new int[10]; 
int val[] = new int[10]; 

Scanner in = new Scanner(System.in);

System.out.println(&quot;Enter the no of items&quot;);
n = in.nextInt();

System.out.println(&quot;Enter the weight of the items&quot;);
for(i=1;i&lt;=n;i++)
{
wt[i] = in.nextInt();
}

System.out.println(&quot;Enter the value of the items&quot;);
for(i=1;i&lt;=n;i++)
{
val[i] = in.nextInt();
}

System.out.println(&quot;Enter the capacity of the knapsack&quot;);
W = in.nextInt();

System.out.println(&quot;The maximum value in knapsack of capacity &quot; + W +
&quot; is: &quot;+knapSack(W, wt, val, n));
}

public static int knapSack(int W, int wt[], int val[], int n)
{
int i, j;
int v[][] = new int[n+1][W+1];


for (i = 0; i &lt;= n; i++)
{

for (j = 0; j &lt;= W; j++)
{
if (i==0 || j==0)
v[i][j] = 0;
else if (j-wt[i]&lt;0)
v[i][j] = v[i-1][j];
else
v[i][j] = max(v[i-1][j],val[i] + v[i-1][j-wt[i]]);
}
}
return v[n][W];
}
public static int max(int a, int b)
{
return (a &gt; b)? a : b;
}

}

---------------------------------------------------------------------------------------------------------------------

11. Design and implement in Java to find a subset of a given set S = {Sl, S2,. ...,Sn} of n
positive integers whose SUM is equal to a given positive integer d. For example, if S ={1, 2, 5,
6, 8} and d= 9, there are two solutions {1,2,6}and {1,8}. Display a suitable message, if the
given problem instance doesn&#39;t have a solution.

---------------------------------------------------------------------------------------------------------------------

package subset;
import java.util.Scanner;
public class Subset {
static int x[] = new int[20];
static int s[] = new int[20];
static int d,flag=0;
public static void main(String[] args) {

int i,n,sum=0;
Scanner in = new Scanner(System.in);
System.out.println(&quot;Enter the no of elements&quot;);
n = in.nextInt();
System.out.println(&quot;Enter the elements&quot;);
for(i=1;i&lt;=n;i++)
s[i] = in.nextInt();
System.out.println(&quot;Enter the value of d:&quot;);
d = in.nextInt();
for(i=1;i&lt;=n;i++) {
sum = sum + s[i];
}

if(sum&lt;d || s[1]&gt;d) {
System.out.println(&quot;The given problem instance does not
have a solution&quot;);
System.exit(0);
}
else{
System.out.println(&quot;Subsets are:&quot;);

SumofSub(0,1,sum);
}
if(flag ==0)
{
System.out.println(&quot;No subset possible&quot;);
System.exit(0);
} }

public static void SumofSub(int m,int k,int r)
{
int i;
x[k] = 1;
if(m+s[k] == d)
{
flag =1;
System.out.print(&quot;{&quot;);
for(i=1;i&lt;=k;i++) {
if(x[i] == 1)
System.out.print(s[i] + &quot; &quot;);
}
System.out.print(&quot;}\n&quot;);
}
else if((m+s[k]+s[k+1])&lt;= d)
SumofSub(m+s[k],k+1,r-s[k]);
if((m+r-s[k]&gt;=d) &amp;&amp; (m+s[k+1]&lt;=d)) {
x[k]=0;
SumofSub(m,k+1,r-s[k]);
}
}
}
